import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
from rest_framework import status
from rest_framework.views import APIView
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated, AllowAny
from rest_framework.response import Response
from django.conf import settings
from django.utils import timezone
from django.db import transaction as db_transaction
from django.shortcuts import redirect

from .models import Transaction, PremiumSubscription, DownloadCredit
from apps.cv_app.models import CV

import hmac
import hashlib
import json
import logging

# Assurez-vous d'importer ou de simuler le client FedaPay si vous l'utilisez
try:
    import fedapay
except ImportError:
    fedapay = None # La v√©rification est toujours utile, mais les appels seront remplac√©s

logger = logging.getLogger(__name__)


def get_payment_session():
    """Cr√©e une session requests configur√©e pour les API de paiement"""
    session = requests.Session()
    # Configuration de la strat√©gie de relance (Retry)
    retry_strategy = Retry(
        total=3,
        status_forcelist=[429, 500, 502, 503, 504],
        backoff_factor=1
    )
    adapter = HTTPAdapter(max_retries=retry_strategy)
    session.mount("https://", adapter)
    session.mount("http://", adapter)
    return session

# =====================================================================
# üõ†Ô∏è NOUVELLE FONCTION UTILITAIRE : Interrogation FedaPay par HTTP
# =====================================================================
def get_fedapay_transaction_status(fedapay_id: str) -> str:
    """Interroge l'API FedaPay pour obtenir le statut d'une transaction via HTTP."""
    fedapay_url = f"{settings.FEDAPAY_API_URL}/transactions/{fedapay_id}"
    session = get_payment_session()
    
    headers = {
        'Authorization': f'Bearer {settings.FEDAPAY_SECRET_KEY}',
        'Accept': 'application/json',
    }
    
    try:
        response = session.get(fedapay_url, headers=headers, timeout=10)
        response.raise_for_status() # L√®ve une exception pour les codes 4xx/5xx
        
        fedapay_data = response.json()
        transaction_data = fedapay_data.get('v1/transaction') or fedapay_data.get('transaction') or fedapay_data
        
        status_feda = transaction_data.get('status')
        if not status_feda:
            raise Exception("Statut FedaPay introuvable dans la r√©ponse.")
            
        return status_feda
        
    except requests.exceptions.RequestException as e:
        logger.error(f" Erreur r√©seau/API FedaPay lors de la r√©cup√©ration: {str(e)}")
        raise # On propage l'erreur pour la g√©rer dans CheckTransactionStatusView


# =====================================================================
# üîµ 1Ô∏è‚É£ CREATION D‚ÄôUNE TRANSACTION (CORRIG√âE : return_url)
# =====================================================================
class CreateTransactionView(APIView):
    """Cr√©e une transaction via l'API REST FedaPay avec callback_url personnalis√©."""
    permission_classes = [IsAuthenticated]
    
    def post(self, request):
        user = request.user
        transaction_type = request.data.get('transaction_type')
        cv_id = request.data.get('cv_id')
        
        # 1. D√©finition du Montant et de la Description
        cv = None
        amount = 0
        
        if transaction_type == 'premium_subscription':
            amount = 5000
            description = f"Abonnement Premium - 1 mois - {user.email}"
        elif transaction_type == 'one_time_download':
            if not cv_id:
                return Response(
                    {'error': 'ID du CV requis pour le t√©l√©chargement unique'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            try:
                cv = CV.objects.get(id=cv_id, owner=user) 
            except CV.DoesNotExist:
                return Response(
                    {'error': 'CV introuvable ou non poss√©d√©'},
                    status=status.HTTP_404_NOT_FOUND
                )
            amount = 200
            description = f"T√©l√©chargement CV: {cv.title} - {user.email}"
        else:
            return Response(
                {'error': 'Type de transaction invalide'},
                status=status.HTTP_400_BAD_REQUEST
            )
            
        if amount <= 0:
            return Response({'error': 'Montant invalide'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        # 2. Cr√©er IMM√âDIATEMENT la transaction en DB pour avoir l'ID local
        reference_id = f'CV{user.id}_{int(timezone.now().timestamp())}'
        
        with db_transaction.atomic():
            transaction_obj = Transaction.objects.create(
                user=user,
                cv=cv,
                fedapay_transaction_id='PENDING',  # Temporaire
                fedapay_token='PENDING',
                transaction_type=transaction_type,
                amount=amount,
                currency='XOF',
                description=description,
                status='pending',
                metadata={
                    'cv_id': cv_id,
                    'cv_title': cv.title if cv else None,
                    'reference_id': reference_id
                }
            )
        
        local_transaction_id = transaction_obj.id  # ‚úÖ ID local Django
        
        # 3. Pr√©paration de la Requ√™te FedaPay avec l'ID local dans callback_url
        session = get_payment_session()
        fedapay_url = f"{settings.FEDAPAY_API_URL}/transactions"
        
        # ‚úÖ SOLUTION: Inclure l'ID local dans le callback_url
        callback_url = f"{settings.FRONTEND_URL}/payment/success?transaction_id={local_transaction_id}"
        webhook_url = f"{settings.BACKEND_DOMAIN}/api/v1/payments/webhook/"
        
        payload = {
            "description": description,
            "amount": amount,
            "currency": {
                "iso": "XOF"
            },
            "callback_url": callback_url,  # ‚úÖ URL avec ID local
            "webhook_url": webhook_url,
            "reference": reference_id, 
            "customer": {
                "firstname": user.first_name or "Utilisateur",
                "lastname": user.last_name or "CV",
                "email": user.email,
                "phone_number": {
                    "number": request.data.get("phone_number", "+22967796730"),
                    "country": request.data.get("phone_country", "bj")
                }
            }
        }
        
        headers = {
            'Authorization': f'Bearer {settings.FEDAPAY_SECRET_KEY}',
            'Content-Type': 'application/json',
        }
        
        try:
            # 4. Envoi de la Requ√™te
            response = session.post(
                fedapay_url,
                headers=headers,
                json=payload,
                timeout=30,
            )
            
            fedapay_data = response.json()

            # 5. Traitement de la R√©ponse
            if response.status_code in [200, 201]:
                
                transaction_data = fedapay_data.get('v1/transaction') or fedapay_data.get('transaction') or fedapay_data
                
                fedapay_transaction_id = transaction_data.get('id')
                fedapay_token = transaction_data.get('payment_token')
                payment_url = transaction_data.get('payment_url')
                
                if not all([fedapay_transaction_id, payment_url]):
                    logger.error(f"‚ùå Donn√©es critiques FedaPay manquantes")
                    # Supprimer la transaction temporaire
                    transaction_obj.delete()
                    raise Exception("La r√©ponse FedaPay est incompl√®te.")
                
                # 6. Mettre √† jour avec les vraies donn√©es FedaPay
                with db_transaction.atomic():
                    transaction_obj.fedapay_transaction_id = fedapay_transaction_id
                    transaction_obj.fedapay_token = fedapay_token or 'N/A'
                    transaction_obj.metadata['fedapay_response'] = fedapay_data
                    transaction_obj.save()
                
                logger.info(f"‚úÖ Transaction cr√©√©e: ID local={transaction_obj.id}, FedaPay={fedapay_transaction_id}")
                
                return Response({
                    'success': True,
                    'transaction_id': transaction_obj.id,  # ID local
                    'fedapay_token': fedapay_token,
                    'payment_url': payment_url, 
                }, status=status.HTTP_201_CREATED)
            
            else:
                # Supprimer la transaction temporaire en cas d'erreur
                transaction_obj.delete()
                
                error_message = fedapay_data.get('message') or fedapay_data.get('error') or response.text
                logger.error(f"‚ùå Erreur FedaPay API ({response.status_code}): {error_message}")
                
                if response.status_code == 401:
                    detail = "Cl√© API FedaPay invalide. V√©rifiez FEDAPAY_SECRET_KEY."
                else:
                    detail = f"Erreur externe: {error_message}"
                    
                return Response(
                    {'error': 'Erreur API FedaPay', 'detail': detail},
                    status=status.HTTP_500_INTERNAL_SERVER_ERROR
                )
        
        except requests.exceptions.RequestException as e:
            transaction_obj.delete()  # Nettoyer
            logger.error(f"‚ùå Erreur r√©seau FedaPay: {str(e)}")
            return Response(
                {'error': 'Erreur r√©seau/Timeout vers FedaPay'},
                status=status.HTTP_503_SERVICE_UNAVAILABLE
            )
        except Exception as e:
            transaction_obj.delete()  # Nettoyer
            logger.error(f"‚ùå Erreur critique: {str(e)}", exc_info=True)
            return Response(
                {'error': 'Erreur serveur interne'},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


# =====================================================================
# üü¢ 2Ô∏è‚É£ CALLBACK FedaPay (Redirection vers le Front-end) (INCHANG√â)
# =====================================================================
@api_view(['GET'])
@permission_classes([AllowAny])  
def fedapay_callback(request):
    """
    Endpoint appel√© par FedaPay apr√®s le paiement (via callback_url).
    Redirige l'utilisateur vers la page Front-end pour la v√©rification finale.
    """
    fedapay_id = request.GET.get('transaction_id')
    status_code = request.GET.get('status')
    
    logger.info(f"üîî Callback FedaPay re√ßu: fedapay_id={fedapay_id}, status={status_code}")
    
    frontend_url = settings.FRONTEND_URL or 'http://localhost:3000'
    
    try:
        transaction = Transaction.objects.get(fedapay_transaction_id=fedapay_id)
        local_id = transaction.id
    except Transaction.DoesNotExist:
        local_id = None
    
    
    # üõë Redirection vers la Page de Succ√®s Front-end
    redirect_url = (
        f"{frontend_url}/payment/success"
        f"?transaction_id={local_id or fedapay_id}"
        f"&fedapay_status={status_code}" 
    )
    
    logger.info(f"üîó Redirection vers le Front-end: {redirect_url}")
    return redirect(redirect_url)


# =====================================================================
# üü° 3Ô∏è‚É£ V√âRIFICATION DU STATUT POST-REDIRECTION (CORRIG√âE : Utilisation de requests)
# =====================================================================
class CheckTransactionStatusView(APIView):
    """
    V√©rifie le statut d'une transaction via l'ID local (appel√© par le Front-end).
    Effectue une v√©rification aupr√®s de FedaPay si le statut est toujours 'pending'.
    """
    permission_classes = [IsAuthenticated]
    
    def get(self, request, transaction_id): # transaction_id est l'ID local Django
        user = request.user
        
        try:
            # 1. R√©cup√©rer la transaction en base de donn√©es
            transaction = Transaction.objects.get(
                id=transaction_id,
                user=user
            )
        except Transaction.DoesNotExist:
            return Response(
                {'error': 'Transaction non trouv√©e ou non autoris√©e'},
                status=status.HTTP_404_NOT_FOUND
            )
            
        fedapay_id = transaction.fedapay_transaction_id
        
        # 2. Si d√©j√† approuv√©e en DB (via Webhook), retourner le statut imm√©diatement
        if transaction.status == 'approved':
            return Response({
                'status': 'approved',
                'cv_id': transaction.cv.id if transaction.cv else None,
                'transaction_type': transaction.transaction_type,
            })
        
        # 3. Sinon, v√©rifier aupr√®s de FedaPay via requ√™tes HTTP
        try:
            fedapay_status = get_fedapay_transaction_status(fedapay_id) # ‚úÖ UTILISATION DE LA FONCTION HTTP
            
            if fedapay_status == 'approved':
                
                # üõë LOGIQUE D'ACTIVATION (si le Webhook a √©t√© manqu√©)
                self._handle_approved_transaction(transaction) 
                
                logger.info(f"‚úÖ Transaction {transaction_id} approuv√©e et acc√®s accord√© via CheckStatus")
                
                return Response({
                    'status': 'approved',
                    'cv_id': transaction.cv.id if transaction.cv else None,
                    'transaction_type': transaction.transaction_type,
                })
            
            elif fedapay_status in ['declined', 'canceled']:
                # Mettre √† jour la DB si FedaPay a un statut final
                with db_transaction.atomic():
                    transaction.status = fedapay_status
                    transaction.save()
                    
                return Response({
                    'status': fedapay_status,
                    'cv_id': None,
                    'transaction_type': transaction.transaction_type,
                })
            
            else:
                # Statut 'pending' ou autre statut temporaire
                return Response({
                    'status': fedapay_status,
                    'cv_id': None,
                    'transaction_type': transaction.transaction_type,
                })
                
        except Exception as e:
            logger.error(f"‚ùå Erreur v√©rification FedaPay pour {fedapay_id}: {str(e)}", exc_info=True)
            # Retourner une erreur serveur et le statut 'pending'
            return Response(
                {'error': 'Erreur serveur lors de la v√©rification externe', 'status': 'pending'},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
            
    @db_transaction.atomic
    def _handle_approved_transaction(self, transaction_obj):
        """Logique d'activation manuelle, copi√©e de la m√©thode du Webhook pour la r√©silience."""
        
        if transaction_obj.status == 'approved':
            logger.warning(f" Transaction {transaction_obj.id} d√©j√† approuv√©e. Ignor√©.")
            return

        transaction_obj.status = 'approved'
        transaction_obj.approved_at = timezone.now()
        transaction_obj.save()
        
        user = transaction_obj.user
        
        # CAS 1: PREMIUM
        if transaction_obj.transaction_type == 'premium_subscription':
            subscription, created = PremiumSubscription.objects.get_or_create(user=user)
            subscription.transaction = transaction_obj
            subscription.activate_subscription(duration_days=30)
            
            user.is_premium_subscriber = True 
            user.save()
            
        
        # CAS 2: T√âL√âCHARGEMENT UNIQUE
        elif transaction_obj.transaction_type == 'one_time_download':
            DownloadCredit.objects.get_or_create(
                user=user,
                cv=transaction_obj.cv,
                transaction=transaction_obj,
                defaults={'is_used': False}
            )
            user.download_credits = (user.download_credits or 0) + 1
            user.save()


# =====================================================================
# üî¥ 4Ô∏è‚É£ WEBHOOK FedaPay ‚Äî APPROBATION & √âCHEC (INCHANG√â)
# =====================================================================
class FedaPayWebhookView(APIView):
    # ... (Le code du Webhook reste inchang√©)
    permission_classes = [AllowAny]
    
    def post(self, request):
        # 1. V√©rifier la signature (IMPORTANT POUR LA S√âCURIT√â)
        signature = request.headers.get('X-FedaPay-Signature')
        
        if settings.DEBUG and not signature:
            logger.warning(" MODE DEBUG: V√©rification signature ignor√©e.")
        elif not self._verify_signature(request.body, signature):
            logger.warning("Signature webhook invalide")
            return Response(
                {'error': 'Signature invalide'},
                status=status.HTTP_403_FORBIDDEN
            )
        
        # 2. Parser les donn√©es et g√©rer l'√©v√©nement
        try:
            event_data = request.data
            transaction_data = event_data.get('entity', {})
            fedapay_transaction_id = transaction_data.get('id')
            
            if not fedapay_transaction_id:
                logger.error(" ID transaction FedaPay manquant dans le Webhook.")
                return Response({'error': 'ID transaction manquant'}, status=status.HTTP_400_BAD_REQUEST)
            
            # 3. R√©cup√©rer notre transaction
            try:
                transaction_obj = Transaction.objects.get(fedapay_transaction_id=fedapay_transaction_id)
            except Transaction.DoesNotExist:
                logger.error(f" Transaction DB introuvable pour ID FedaPay: {fedapay_transaction_id}")
                return Response({'error': 'Transaction introuvable'}, status=status.HTTP_404_NOT_FOUND)
            
            # 4. Traiter selon le statut FedaPay
            status_feda = transaction_data.get('status')
            
            if status_feda == 'approved':
                self._handle_approved_transaction(transaction_obj)
            
            elif status_feda in ['declined', 'canceled']:
                transaction_obj.status = status_feda
                transaction_obj.save()
                logger.info(f" Transaction {status_feda}: {transaction_obj.id}")
            
            return Response({'status': 'success'}, status=status.HTTP_200_OK)
            
        except Exception as e:
            logger.error(f" Erreur webhook: {str(e)}", exc_info=True)
            return Response(
                {'error': 'Erreur serveur'},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
    
    def _verify_signature(self, payload, signature):
        # ... (Logique de v√©rification de signature inchang√©e)
        if not signature:
            return False
        
        webhook_secret = getattr(settings, 'FEDAPAY_WEBHOOK_SECRET', '')
        if not webhook_secret:
            logger.error(" FEDAPAY_WEBHOOK_SECRET non configur√©")
            return False
        
        expected_signature = hmac.new(
            webhook_secret.encode('utf-8'),
            payload,
            hashlib.sha256
        ).hexdigest()
        
        return hmac.compare_digest(expected_signature, signature)
    
    @db_transaction.atomic
    def _handle_approved_transaction(self, transaction_obj):
        """Active Premium ou Cr√©e un Cr√©dit (utilis√© par le Webhook et CheckStatus)"""
        # Ne rien faire si d√©j√† approuv√© (protection contre les re-webhooks)
        if transaction_obj.status == 'approved':
            logger.warning(f" Transaction {transaction_obj.id} d√©j√† approuv√©e. Ignor√©.")
            return

        transaction_obj.status = 'approved'
        transaction_obj.approved_at = timezone.now()
        transaction_obj.save()
        
        user = transaction_obj.user
        
        # CAS 1: PREMIUM
        if transaction_obj.transaction_type == 'premium_subscription':
            subscription, created = PremiumSubscription.objects.get_or_create(user=user)
            subscription.transaction = transaction_obj
            subscription.activate_subscription(duration_days=30)
            
            user.is_premium_subscriber = True 
            user.save()
            
            logger.info(f" Premium activ√©: {user.email} jusqu'au {subscription.end_date.date()}")
        
        # CAS 2: T√âL√âCHARGEMENT UNIQUE
        elif transaction_obj.transaction_type == 'one_time_download':
            DownloadCredit.objects.get_or_create(
                user=user,
                cv=transaction_obj.cv,
                transaction=transaction_obj,
                defaults={'is_used': False}
            )
            
            user.download_credits = (user.download_credits or 0) + 1
            user.save()
            
            logger.info(f" Cr√©dit ajout√©: {user.email} - CV: {transaction_obj.cv.title if transaction_obj.cv else 'N/A'}")


# =====================================================================
#  VUES DE PERMISSION ET CR√âDIT (Logique existante - INCHANG√âES)
# =====================================================================

class CheckDownloadPermissionView(APIView):
    # ... (Logique inchang√©e)
    permission_classes = [IsAuthenticated]
    
    def get(self, request, cv_id):
        user = request.user
        
        try:
            cv = CV.objects.get(id=cv_id, owner=user)
        except CV.DoesNotExist:
            return Response(
                {'error': 'CV introuvable'},
                status=status.HTTP_404_NOT_FOUND
            )
        
        if user.is_premium_subscriber:
            try:
                subscription = PremiumSubscription.objects.get(user=user)
                if subscription.is_valid():
                    return Response({
                        'can_download': True,
                        'reason': 'premium',
                        'message': 'T√©l√©chargement illimit√© (Premium)'
                    })
            except PremiumSubscription.DoesNotExist:
                pass
        
        unused_credit = DownloadCredit.objects.filter(
            user=user,
            cv=cv,
            is_used=False
        ).first()
        
        if unused_credit:
            return Response({
                'can_download': True,
                'reason': 'credit',
                'credit_id': unused_credit.id,
                'message': 'Cr√©dit de t√©l√©chargement disponible'
            })
        
        return Response({
            'can_download': False,
            'reason': 'no_permission',
            'message': 'Abonnement Premium ou cr√©dit requis'
        })


class ConsumeDownloadCreditView(APIView):
    # ... (Logique inchang√©e)
    permission_classes = [IsAuthenticated]
    
    def post(self, request):
        credit_id = request.data.get('credit_id')
        
        try:
            credit = DownloadCredit.objects.get(
                id=credit_id,
                user=request.user,
                is_used=False
            )
            
            if credit.use_credit(): 
                request.user.download_credits = max(0, request.user.download_credits - 1)
                request.user.save()
                
                logger.info(f" Cr√©dit consomm√©: {credit_id} - User: {request.user.email}")
                return Response({'message': 'Cr√©dit consomm√© avec succ√®s'})
            else:
                return Response(
                    {'error': 'Cr√©dit d√©j√† utilis√©'},
                    status=status.HTTP_400_BAD_REQUEST
                )
                
        except DownloadCredit.DoesNotExist:
            return Response(
                {'error': 'Cr√©dit introuvable'},
                status=status.HTTP_404_NOT_FOUND
            )